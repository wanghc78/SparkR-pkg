% Generated by roxygen2 (4.0.2): do not edit by hand
\docType{methods}
\name{fullOuterJoin}
\alias{fullOuterJoin}
\alias{fullOuterJoin,RDD,RDD,integer-method}
\alias{fullOuterJoin,RDD,RDD-method}
\title{Full outer join two RDDs}
\usage{
fullOuterJoin(rdd1, rdd2, numPartitions)

\S4method{fullOuterJoin}{RDD,RDD,integer}(rdd1, rdd2, numPartitions)
}
\arguments{
\item{rdd1}{An RDD to be joined. Should be an RDD where each element is
list(K, V).}

\item{rdd2}{An RDD to be joined. Should be an RDD where each element is
list(K, V).}

\item{numPartitions}{Number of partitions to create.}
}
\value{
For each element (k, v) in rdd1 and (k, w) in rdd2, the resulting RDD
        will contain all pairs (k, (v, w)) for both (k, v) in rdd1 and and
        (k, w) in rdd2, or the pair (k, (NULL, w))/(k, (v, NULL)) if no elements
        in rdd1/rdd2 have key k.
}
\description{
This function full-outer-joins two RDDs where every element is of the form
list(K, V).
The key types of the two RDDs should be the same.
}
\examples{
\dontrun{
sc <- sparkR.init()
rdd1 <- parallelize(sc, list(list(1, 2), list(1, 3), list(3, 3)))
rdd2 <- parallelize(sc, list(list(1, 1), list(2, 4)))
fullOuterJoin(rdd1, rdd2, 2L) # list(list(1, list(2, 1)),
                              #      list(1, list(3, 1)),
                              #      list(3, list(3, NULL)),
                              #      list(2, list(NULL, 4)))
}
}

